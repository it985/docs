<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>001.JVM001 | 云少的笔记</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="一个基于VuePress的 知识管理">
    <meta name="keywords" content="云少,云遇未晚,笔记,程序员,Java">
    <meta name="theme-color" content="#11a8cd">
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <link rel="preload" href="/assets/css/0.styles.6c7ae71d.css" as="style"><link rel="preload" href="/assets/js/app.b9afd737.js" as="script"><link rel="preload" href="/assets/js/2.a4791f69.js" as="script"><link rel="preload" href="/assets/js/36.01c30e39.js" as="script"><link rel="prefetch" href="/assets/js/10.946855a4.js"><link rel="prefetch" href="/assets/js/11.d3af7d6d.js"><link rel="prefetch" href="/assets/js/12.0749dd3c.js"><link rel="prefetch" href="/assets/js/13.030226f4.js"><link rel="prefetch" href="/assets/js/14.a7e88ce9.js"><link rel="prefetch" href="/assets/js/15.c4e94717.js"><link rel="prefetch" href="/assets/js/16.62ff03cd.js"><link rel="prefetch" href="/assets/js/17.d55d6664.js"><link rel="prefetch" href="/assets/js/18.e29f5bd1.js"><link rel="prefetch" href="/assets/js/19.e623c427.js"><link rel="prefetch" href="/assets/js/20.e52da6d2.js"><link rel="prefetch" href="/assets/js/21.00bf58ff.js"><link rel="prefetch" href="/assets/js/22.7bf04e6e.js"><link rel="prefetch" href="/assets/js/23.c6790062.js"><link rel="prefetch" href="/assets/js/24.323feccf.js"><link rel="prefetch" href="/assets/js/25.6537a707.js"><link rel="prefetch" href="/assets/js/26.fa629e87.js"><link rel="prefetch" href="/assets/js/27.5228a8cd.js"><link rel="prefetch" href="/assets/js/28.adc1c264.js"><link rel="prefetch" href="/assets/js/29.e20c1d49.js"><link rel="prefetch" href="/assets/js/3.47f77408.js"><link rel="prefetch" href="/assets/js/30.3177de79.js"><link rel="prefetch" href="/assets/js/31.cf2f7144.js"><link rel="prefetch" href="/assets/js/32.e8a5684f.js"><link rel="prefetch" href="/assets/js/33.a809a527.js"><link rel="prefetch" href="/assets/js/34.f76515d7.js"><link rel="prefetch" href="/assets/js/35.66b8753b.js"><link rel="prefetch" href="/assets/js/37.1012c2f9.js"><link rel="prefetch" href="/assets/js/38.0e07dde9.js"><link rel="prefetch" href="/assets/js/39.1ce96cb1.js"><link rel="prefetch" href="/assets/js/4.c2e3e96b.js"><link rel="prefetch" href="/assets/js/40.07c178d7.js"><link rel="prefetch" href="/assets/js/41.9aa7c859.js"><link rel="prefetch" href="/assets/js/42.d44a7bf3.js"><link rel="prefetch" href="/assets/js/43.562ad682.js"><link rel="prefetch" href="/assets/js/44.246fdadc.js"><link rel="prefetch" href="/assets/js/45.a23440d8.js"><link rel="prefetch" href="/assets/js/46.31d33c11.js"><link rel="prefetch" href="/assets/js/5.0fbf58fa.js"><link rel="prefetch" href="/assets/js/6.2a27d653.js"><link rel="prefetch" href="/assets/js/7.3475694e.js"><link rel="prefetch" href="/assets/js/8.436f007f.js"><link rel="prefetch" href="/assets/js/9.48d1d3ba.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6c7ae71d.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="云少的笔记" class="logo"> <span class="site-name can-hide">云少的笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="指南" class="dropdown-title"><a href="/pages/a2f161/" class="link-title">指南</a> <span class="title" style="display:none;">指南</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/52d5c3/" class="nav-link">主题初衷与诞生</a></li><li class="dropdown-item"><!----> <a href="/pages/a2f161/" class="nav-link">介绍</a></li><li class="dropdown-item"><!----> <a href="/pages/793dcb/" class="nav-link">快速上手</a></li><li class="dropdown-item"><!----> <a href="/pages/2f674a/" class="nav-link">目录结构</a></li><li class="dropdown-item"><!----> <a href="/pages/33d574/" class="nav-link">核心配置和约定</a></li><li class="dropdown-item"><!----> <a href="/pages/088c16/" class="nav-link">自动生成front matter</a></li><li class="dropdown-item"><!----> <a href="/pages/d0d7eb/" class="nav-link">Markdown 容器</a></li><li class="dropdown-item"><!----> <a href="/pages/197691/" class="nav-link">Markdown 中使用组件</a></li><li class="dropdown-item"><h4>相关文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8dfab5/" class="nav-link">使目录栏支持h2~h6标题</a></li><li class="dropdown-subitem"><a href="/pages/dd027d/" class="nav-link">如何让你的笔记更有表现力</a></li><li class="dropdown-subitem"><a href="/pages/2b8e22/" class="nav-link">批量操作front matter工具</a></li><li class="dropdown-subitem"><a href="/pages/0fc1d2/" class="nav-link">部署</a></li><li class="dropdown-subitem"><a href="/pages/9ae0bd/" class="nav-link">关于写文章和H1标题</a></li><li class="dropdown-subitem"><a href="/pages/26997d/" class="nav-link">关于博客搭建与管理</a></li><li class="dropdown-subitem"><a href="/pages/c5a54d/" class="nav-link">在线编辑和新增文章的方法</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="配置" class="dropdown-title"><a href="/pages/a20ce8/" class="link-title">配置</a> <span class="title" style="display:none;">配置</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/a20ce8/" class="nav-link">主题配置</a></li><li class="dropdown-item"><!----> <a href="/pages/f14bdb/" class="nav-link">首页配置</a></li><li class="dropdown-item"><!----> <a href="/pages/3216b0/" class="nav-link">front matter配置</a></li><li class="dropdown-item"><!----> <a href="/pages/54651a/" class="nav-link">目录页配置</a></li><li class="dropdown-item"><!----> <a href="/pages/1cc523/" class="nav-link">添加摘要</a></li><li class="dropdown-item"><!----> <a href="/pages/f51918/" class="nav-link">修改主题颜色和样式</a></li><li class="dropdown-item"><!----> <a href="/pages/ce175c/" class="nav-link">评论栏</a></li></ul></div></div><div class="nav-item"><a href="/pages/db78e2/" class="nav-link">资源</a></div><div class="nav-item"><a href="/pages/5d571c/" class="nav-link">案例</a></div><div class="nav-item"><a href="/pages/9cc27d/" class="nav-link">问答</a></div><div class="nav-item"><a href="/pages/1b12ed/" class="nav-link">赞助</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="指南" class="dropdown-title"><a href="/pages/a2f161/" class="link-title">指南</a> <span class="title" style="display:none;">指南</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/52d5c3/" class="nav-link">主题初衷与诞生</a></li><li class="dropdown-item"><!----> <a href="/pages/a2f161/" class="nav-link">介绍</a></li><li class="dropdown-item"><!----> <a href="/pages/793dcb/" class="nav-link">快速上手</a></li><li class="dropdown-item"><!----> <a href="/pages/2f674a/" class="nav-link">目录结构</a></li><li class="dropdown-item"><!----> <a href="/pages/33d574/" class="nav-link">核心配置和约定</a></li><li class="dropdown-item"><!----> <a href="/pages/088c16/" class="nav-link">自动生成front matter</a></li><li class="dropdown-item"><!----> <a href="/pages/d0d7eb/" class="nav-link">Markdown 容器</a></li><li class="dropdown-item"><!----> <a href="/pages/197691/" class="nav-link">Markdown 中使用组件</a></li><li class="dropdown-item"><h4>相关文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8dfab5/" class="nav-link">使目录栏支持h2~h6标题</a></li><li class="dropdown-subitem"><a href="/pages/dd027d/" class="nav-link">如何让你的笔记更有表现力</a></li><li class="dropdown-subitem"><a href="/pages/2b8e22/" class="nav-link">批量操作front matter工具</a></li><li class="dropdown-subitem"><a href="/pages/0fc1d2/" class="nav-link">部署</a></li><li class="dropdown-subitem"><a href="/pages/9ae0bd/" class="nav-link">关于写文章和H1标题</a></li><li class="dropdown-subitem"><a href="/pages/26997d/" class="nav-link">关于博客搭建与管理</a></li><li class="dropdown-subitem"><a href="/pages/c5a54d/" class="nav-link">在线编辑和新增文章的方法</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="配置" class="dropdown-title"><a href="/pages/a20ce8/" class="link-title">配置</a> <span class="title" style="display:none;">配置</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/a20ce8/" class="nav-link">主题配置</a></li><li class="dropdown-item"><!----> <a href="/pages/f14bdb/" class="nav-link">首页配置</a></li><li class="dropdown-item"><!----> <a href="/pages/3216b0/" class="nav-link">front matter配置</a></li><li class="dropdown-item"><!----> <a href="/pages/54651a/" class="nav-link">目录页配置</a></li><li class="dropdown-item"><!----> <a href="/pages/1cc523/" class="nav-link">添加摘要</a></li><li class="dropdown-item"><!----> <a href="/pages/f51918/" class="nav-link">修改主题颜色和样式</a></li><li class="dropdown-item"><!----> <a href="/pages/ce175c/" class="nav-link">评论栏</a></li></ul></div></div><div class="nav-item"><a href="/pages/db78e2/" class="nav-link">资源</a></div><div class="nav-item"><a href="/pages/5d571c/" class="nav-link">案例</a></div><div class="nav-item"><a href="/pages/9cc27d/" class="nav-link">问答</a></div><div class="nav-item"><a href="/pages/1b12ed/" class="nav-link">赞助</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>001.JVM001</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d236d6/#_1、知识点汇总" class="sidebar-link">1、知识点汇总</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_2、知识点详解" class="sidebar-link">2、知识点详解：</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_1、jvm内存模型" class="sidebar-link">1、JVM内存模型：</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_2、栈" class="sidebar-link">2、栈：</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_3、本地方法栈" class="sidebar-link">3、本地方法栈</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_4、程序计数器" class="sidebar-link">4、程序计数器</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_5、堆" class="sidebar-link">5、堆</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_6、方法区" class="sidebar-link">6、方法区：</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_7、jvm-内存可见性" class="sidebar-link">7、JVM 内存可见性</a></li></ul></li><li><a href="/pages/d236d6/#_3、说说类加载与卸载" class="sidebar-link">3、说说类加载与卸载</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#加载过程" class="sidebar-link">加载过程</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_1、加载机制-双亲委派模式" class="sidebar-link">1、加载机制-双亲委派模式</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#优点" class="sidebar-link">优点:</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_2、分代回收" class="sidebar-link">2、分代回收</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_3、回收算法" class="sidebar-link">3、回收算法</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#a、g1算法" class="sidebar-link">a、G1算法</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#b、zgc算法" class="sidebar-link">b、ZGC算法</a></li></ul></li><li><a href="/pages/d236d6/#_4、简述一下jvm的内存模型" class="sidebar-link">4、简述一下JVM的内存模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_1-jvm内存模型简介" class="sidebar-link">1. JVM内存模型简介</a></li><li class="sidebar-sub-header level3"><a href="/pages/d236d6/#线程私有区" class="sidebar-link">线程私有区</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_1、程序计数器" class="sidebar-link">1、程序计数器</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_2、虚拟机栈" class="sidebar-link">2、虚拟机栈</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_3、本地方法栈-2" class="sidebar-link">3、本地方法栈</a></li><li class="sidebar-sub-header level3"><a href="/pages/d236d6/#线程共享区" class="sidebar-link">线程共享区</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_1、方法区" class="sidebar-link">1、方法区</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_2、堆" class="sidebar-link">2、堆</a></li></ul></li><li><a href="/pages/d236d6/#_5、说说堆和栈的区别" class="sidebar-link">5、说说堆和栈的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_1、功能不同" class="sidebar-link">1、功能不同</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_2、共享性不同" class="sidebar-link">2、共享性不同</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_3、异常错误不同" class="sidebar-link">3、异常错误不同</a></li><li class="sidebar-sub-header level4"><a href="/pages/d236d6/#_4、空间大小" class="sidebar-link">4、空间大小</a></li></ul></li><li><a href="/pages/d236d6/#_6、-什么时候会触发fullgc" class="sidebar-link">6、 什么时候会触发FullGC</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_7、什么是java虚拟机-为什么java被称作是-平台无关的编程语言" class="sidebar-link">7、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_8、java内存结构" class="sidebar-link">8、Java内存结构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_9、说说对象分配规则" class="sidebar-link">9、说说对象分配规则</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_10、描述一下jvm加载class文件的原理机制" class="sidebar-link">10、描述一下JVM加载class文件的原理机制？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_11、说说java对象创建过程" class="sidebar-link">11、说说Java对象创建过程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_12、知道类的生命周期吗" class="sidebar-link">12、知道类的生命周期吗？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_13、简述java的对象结构" class="sidebar-link">13、简述Java的对象结构</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_14、如何判断对象可以被回收" class="sidebar-link">14、如何判断对象可以被回收？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_15、jvm的永久代中会发生垃圾回收么" class="sidebar-link">15、JVM的永久代中会发生垃圾回收么？</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_16、你知道哪些垃圾收集算法" class="sidebar-link">16、你知道哪些垃圾收集算法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/d236d6/#_17、调优命令有哪些" class="sidebar-link">17、调优命令有哪些？</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/categories/?category=Java" title="分类" data-v-06225672>Java</a></li><li data-v-06225672><a href="/categories/?category=JVM%E7%AF%87" title="分类" data-v-06225672>JVM篇</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="javascript:;" data-v-06225672>云少</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-01-01</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">001.JVM001<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="_001-jvm001"><a href="#_001-jvm001" class="header-anchor">#</a> 001.JVM001</h1> <h2 id="_1、知识点汇总"><a href="#_1、知识点汇总" class="header-anchor">#</a> 1、知识点汇总</h2> <p>JVM是Java运行基础,面试时一定会遇到JVM的有关问题,内容相对集中,但对只是深度要求较高.
<img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm1.png" alt="jvm1"></p> <p>其中内存模型,类加载机制,GC是重点方面.性能调优部分更偏向应用,重点突出实践能力.编译器优化和执行模式部分偏向于理论基础,重点掌握知识点.需了解 <strong>内存模型</strong>各部分作用,保存哪些数据.
<strong>类加载</strong>双亲委派加载机制,常用加载器分别加载哪种类型的类.
<strong>GC分</strong>代回收的思想和依据以及不同垃圾回收算法的回收思路和适合场景.
<strong>性能调优</strong>常有JVM优化参数作用,参数调优的依据,常用的JVM分析工具能分析哪些问题以及使用方法.
<strong>执行模式</strong>解释/编译/混合模式的优缺点,Java7提供的分层编译技术,JIT即时编译技术,OSR栈上替换,C1/C2编译器针对的场景,C2针对的是server模式,优化更激进.新技术方面Java10的graal编译器
<strong>编译器优化</strong>javac的编译过程,ast抽象语法树,编译器优化和运行器优化.</p> <h2 id="_2、知识点详解"><a href="#_2、知识点详解" class="header-anchor">#</a> 2、知识点详解：</h2> <h4 id="_1、jvm内存模型"><a href="#_1、jvm内存模型" class="header-anchor">#</a> 1、JVM内存模型：</h4> <p>线程独占:栈,本地方法栈,程序计数器 线程共享:堆,方法区</p> <h4 id="_2、栈"><a href="#_2、栈" class="header-anchor">#</a> 2、栈：</h4> <p>又称方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法出口等信息.调用方法时执行入栈,方法返回式执行出栈.</p> <h4 id="_3、本地方法栈"><a href="#_3、本地方法栈" class="header-anchor">#</a> 3、本地方法栈</h4> <p>与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈.</p> <h4 id="_4、程序计数器"><a href="#_4、程序计数器" class="header-anchor">#</a> 4、程序计数器</h4> <p>保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行Native方法时,程序计数器为空.</p> <h4 id="_5、堆"><a href="#_5、堆" class="header-anchor">#</a> 5、堆</h4> <p>JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行垃圾的回收管理</p> <h4 id="_6、方法区"><a href="#_6、方法区" class="header-anchor">#</a> 6、方法区：</h4> <p>又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7的永久代和1.8的元空间都是方法区的一种实现</p> <h4 id="_7、jvm-内存可见性"><a href="#_7、jvm-内存可见性" class="header-anchor">#</a> 7、JVM 内存可见性</h4> <p><img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm2.png" alt="jvm2"></p> <p>JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对
主内存操作.由于指令重排序,读写的顺序会被打乱,因此JMM需要提供原子性,可见性,有序性保证.
<img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm3.png" alt="jvm3"></p> <h2 id="_3、说说类加载与卸载"><a href="#_3、说说类加载与卸载" class="header-anchor">#</a> 3、说说类加载与卸载</h2> <h4 id="加载过程"><a href="#加载过程" class="header-anchor">#</a> 加载过程</h4> <p><img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm4.png" alt="jvm4"></p> <p>其中<strong>验证</strong>,<strong>准备</strong>,<strong>解析</strong>合称链接
<strong>加载</strong>通过类的完全限定名,查找此类字节码文件,利用字节码文件创建Class对象.
<strong>验证</strong>确保Class文件符合当前虚拟机的要求,不会危害到虚拟机自身安全.
<strong>准备</strong>进行内存分配,为static修饰的类变量分配内存,并设置初始值(0或null).不包含final修饰的静态变
量,因为final变量在编译时分配.
<strong>解析</strong>将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量
等.
<strong>初始化</strong>主要完成静态块执行以及静态变量的赋值.先初始化父类,再初始化当前类.只有对类主动使用
时才会初始化.
触发条件包括,创建类的实例时,访问类的静态方法或静态变量的时候,使用Class.forName反射类的时
候,或者某个子类初始化的时候.
Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的
类才可以被卸.</p> <h4 id="_1、加载机制-双亲委派模式"><a href="#_1、加载机制-双亲委派模式" class="header-anchor">#</a> 1、加载机制-双亲委派模式</h4> <p><img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm5.png" alt="jvm5"></p> <p>双亲委派模式,即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器.父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载.</p> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点:</h4> <ol><li><p>避免类的重复加载</p></li> <li><p>避免Java的核心API被篡改</p></li></ol> <h4 id="_2、分代回收"><a href="#_2、分代回收" class="header-anchor">#</a> 2、分代回收</h4> <p>分代回收基于两个事实:大部分对象很快就不使用了,还有一部分不会立即无用,但也不会持续很长时间
<img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm6.png" alt="jvm6"></p> <h4 id="_3、回收算法"><a href="#_3、回收算法" class="header-anchor">#</a> 3、回收算法</h4> <h4 id="a、g1算法"><a href="#a、g1算法" class="header-anchor">#</a> a、G1算法</h4> <p>1.9后默认的垃圾回收算法,特点保持高回收率的同时减少停顿.采用每次只清理一部分,而不是清理全
部的增量式清理,以保证停顿时间不会过长
其取消了年轻代与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),一
部分用作年轻代,一部分用作老年代,还有用来存储巨型对象的分区.
同CMS相同,会遍历所有对象,标记引用情况,清除对象后会对区域进行复制移动,以整合碎片空间.
年轻代回收: 并行复制采用复制算法,并行收集,会StopTheWorld.
老年代回收: 会对年轻代一并回收
初始标记完成堆root对象的标记,会StopTheWorld. 并发标记 GC线程和应用线程并发执行. 最终标记
完成三色标记周期,会StopTheWorld. 复制/清楚会优先对可回收空间加大的区域进行回收</p> <h4 id="b、zgc算法"><a href="#b、zgc算法" class="header-anchor">#</a> b、ZGC算法</h4> <p>前面提供的高效垃圾回收算法,针对大堆内存设计,可以处理TB级别的堆,可以做到10ms以下的回收停
顿时间.
<img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm7.png" alt="jvm7"></p> <ul><li>着色指针</li> <li>读屏障</li> <li>并发处理</li> <li>基于region</li> <li>内存压缩(整理)</li></ul> <p>roots标记：标记root对象,会StopTheWorld. 并发标记：利用读屏障与应用线程一起运行标记,可能
会发生StopTheWorld. 清除会清理标记为不可用的对象. roots重定位：是对存活的对象进行移动,以
腾出大块内存空间,减少碎片产生.重定位最开始会StopTheWorld,却决于重定位集与对象总活动集的
比例. 并发重定位与并发标记类似.</p> <h2 id="_4、简述一下jvm的内存模型"><a href="#_4、简述一下jvm的内存模型" class="header-anchor">#</a> 4、简述一下JVM的内存模型</h2> <h4 id="_1-jvm内存模型简介"><a href="#_1-jvm内存模型简介" class="header-anchor">#</a> 1. JVM内存模型简介</h4> <p>JVM定义了不同运行时数据区，他们是用来执行应用程序的。某些区域随着JVM启动及销毁，另外一些区域的数据是线程性独立的，随着线程创建和销毁。jvm内存模型总体架构图如下：（摘自oracle<a href="https://link.jianshu.com/?t=http%3A//www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener noreferrer">官方网站<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）</p> <p><img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm8.png" alt="jvm8"></p> <p>JVM在执行Java程序时，会把它管理的内存划分为若干个的区域，每个区域都有自己的用途和创建
销毁时间。如下图所示，可以分为两大部分，线程私有区和共享区。下图是根据自己理解画的一个
JVM内存模型架构图：
<img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm9.png" alt="jvm9"></p> <p>JVM内存分为线程私有区和线程共享区</p> <h3 id="线程私有区"><a href="#线程私有区" class="header-anchor">#</a> <strong>线程私有区</strong></h3> <h4 id="_1、程序计数器"><a href="#_1、程序计数器" class="header-anchor">#</a> 1、程序计数器</h4> <p>当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，每个线程就需要一个属于自己的计数器来记录下一条要运行的指令。如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为 空。</p> <h4 id="_2、虚拟机栈"><a href="#_2、虚拟机栈" class="header-anchor">#</a> 2、虚拟机栈</h4> <p>线程私有的，与线程在同一时间创建。管理JAVA方法执行的内存模型。每个方法执行时都会创建一个桢栈来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出stackOverﬂowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出 OutofMemoryError。 使用jclasslib工具可以查看class类文件的结构。下图为栈帧结构图：
<img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm10.png" alt="jvm10"></p> <h4 id="_3、本地方法栈-2"><a href="#_3、本地方法栈-2" class="header-anchor">#</a> 3、本地方法栈</h4> <p>与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法（C语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同。</p> <h3 id="线程共享区"><a href="#线程共享区" class="header-anchor">#</a> 线程共享区</h3> <h4 id="_1、方法区"><a href="#_1、方法区" class="header-anchor">#</a> <strong>1</strong>、方法区</h4> <p>线程共享的，用于存放被虚拟机加载的类的元数据信息，如常量、静态变量和即时编译器编译后的代码。若要分代，算是永久代（老年代），以前类大多“static”的，很少被卸载或收集，现回收废弃常量和无用的类。其中运行时常量池存放编译生成的各种常量。（如果hotspot虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的ClassLoader被回收）</p> <h4 id="_2、堆"><a href="#_2、堆" class="header-anchor">#</a> 2、堆</h4> <p>存放对象实例和数组，是垃圾回收的主要区域，分为新生代和老年代。刚创建的对象在新生代的 Eden区中，经过GC后进入新生代的S0区中，再经过GC进入新生代的S1区中，15次GC后仍存在就进入老年代。这是按照一种回收机制进行划分的，不是固定的。若堆的空间不够实例分配，则 OutOfMemoryError
<img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm11.png" alt="jvm11"></p> <div class="language- extra-class"><pre class="language-text"><code>Young Generation 即图中的Eden + From Space（s0） + To Space(s1)
Eden 存放新生的对象
Survivor Space 有两个，存放每次垃圾回收后存活的对象(s0+s1)
Old Generation Tenured Generation 即图中的Old Space 主要存放应用程序中生命周期长的存活对象
</code></pre></div><h2 id="_5、说说堆和栈的区别"><a href="#_5、说说堆和栈的区别" class="header-anchor">#</a> 5、说说堆和栈的区别</h2> <p>栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。</p> <h4 id="_1、功能不同"><a href="#_1、功能不同" class="header-anchor">#</a> 1、功能不同</h4> <p>栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p> <h4 id="_2、共享性不同"><a href="#_2、共享性不同" class="header-anchor">#</a> 2、共享性不同</h4> <p>栈内存是线程私有的。 堆内存是所有线程共有的。</p> <h4 id="_3、异常错误不同"><a href="#_3、异常错误不同" class="header-anchor">#</a> 3、异常错误不同</h4> <p>如果栈内存或者堆内存不足都会抛出异常。 栈空间不足：java.lang.StackOverFlowError。 堆空间不足：java.lang.OutOfMemoryError。</p> <h4 id="_4、空间大小"><a href="#_4、空间大小" class="header-anchor">#</a> 4、空间大小</h4> <p>栈的空间大小远远小于堆的。</p> <h2 id="_6、-什么时候会触发fullgc"><a href="#_6、-什么时候会触发fullgc" class="header-anchor">#</a> 6、 什么时候会触发FullGC</h2> <p>除直接调用System.gc外，触发Full GC执行的情况有如下四种。</p> <p><strong>1.</strong> <strong>旧生代空间不足</strong> 旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不</p> <p>足，则抛出如下错误： java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p> <p><strong>2.</strong> <strong>PermanetGeneration空间满</strong> PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信 息： java.lang.OutOfMemoryError: PermGen space 为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p> <p><strong>3.</strong> <strong>CMSGC时出现promotionfailed和concurrentmodefailure</strong> 对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。 promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行 CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。 应对措施为：增大 survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置- XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。</p> <p><strong>4.</strong> <strong>统计得到的MinorGC晋升到旧生代的平均大小大于旧生代的剩余空间</strong> 这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。 例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生 代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，</p> <p>则执行Full GC。 当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。 除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java- Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p> <h2 id="_7、什么是java虚拟机-为什么java被称作是-平台无关的编程语言"><a href="#_7、什么是java虚拟机-为什么java被称作是-平台无关的编程语言" class="header-anchor">#</a> 7、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</h2> <p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p> <h2 id="_8、java内存结构"><a href="#_8、java内存结构" class="header-anchor">#</a> 8、Java内存结构</h2> <p><img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm12.png" alt="jvm12">
方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有
的内存区域。</p> <ul><li><p><strong>Java堆</strong>（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p></li> <li><p><strong>方法区</strong>（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li> <li><p><strong>程序计数器</strong>（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p></li> <li><p><strong>JVM栈</strong>（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame)用于存储局部变量表、操作栈、动态</p></li> <li><p><strong>链接、方法出口</strong>等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li> <li><p><strong>本地方法栈</strong>（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p></li></ul> <h2 id="_9、说说对象分配规则"><a href="#_9、说说对象分配规则" class="header-anchor">#</a> 9、说说对象分配规则</h2> <ul><li>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</li> <li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</li> <li>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次 Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</li> <li>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</li> <li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查 HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</li></ul> <h2 id="_10、描述一下jvm加载class文件的原理机制"><a href="#_10、描述一下jvm加载class文件的原理机制" class="header-anchor">#</a> 10、描述一下JVM加载class文件的原理机制？</h2> <p>JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时， JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的 Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了 Java平台的安全性，在该机制中，JVM自带Bootstra是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p> <ul><li>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</li> <li>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</li> <li>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</li></ul> <h2 id="_11、说说java对象创建过程"><a href="#_11、说说java对象创建过程" class="header-anchor">#</a> 11、说说Java对象创建过程</h2> <ol><li>JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类（类加载过程在后边讲）</li> <li>为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”</li> <li>将除对象头外的对象内存空间初始化为0</li> <li>对对象头进行必要设置</li></ol> <h2 id="_12、知道类的生命周期吗"><a href="#_12、知道类的生命周期吗" class="header-anchor">#</a> 12、知道类的生命周期吗？</h2> <p>类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程,
如下图；
<img src="https://npm.elemecdn.com/@it985/docsimages/001/jvm13.png" alt="jvm13"></p> <ul><li>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</li> <li>连接，连接又包含三块内容：验证、准备、初始化。
<ul><li>1）验证，文件格式、元数据、字节码、符号引用验证；</li> <li>2）准备，为类的静态变量分配内存，并将其初始化为默认值；</li> <li>3）解析，把类中的符号引用转换为直接引用</li></ul></li> <li>初始化，为类的静态变量赋予正确的初始值</li> <li>使用，new出对象程序中使用</li> <li>卸载，执行垃圾回收</li></ul> <h2 id="_13、简述java的对象结构"><a href="#_13、简述java的对象结构" class="header-anchor">#</a> 13、简述Java的对象结构</h2> <p>Java对象由三个部分组成：对象头、实例数据、对齐填充。</p> <ul><li>对象头由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）。第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。</li> <li>实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）</li> <li>对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）</li></ul> <h2 id="_14、如何判断对象可以被回收"><a href="#_14、如何判断对象可以被回收" class="header-anchor">#</a> 14、如何判断对象可以被回收？</h2> <p>判断对象是否存活一般有两种方式：</p> <ul><li>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</li> <li>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</li></ul> <h2 id="_15、jvm的永久代中会发生垃圾回收么"><a href="#_15、jvm的永久代中会发生垃圾回收么" class="header-anchor">#</a> 15、JVM的永久代中会发生垃圾回收么？</h2> <p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full
GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确
的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (注：Java8
中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p> <h2 id="_16、你知道哪些垃圾收集算法"><a href="#_16、你知道哪些垃圾收集算法" class="header-anchor">#</a> 16、你知道哪些垃圾收集算法</h2> <p>GC最基础的算法有三种： <strong>标记 -清除算法</strong>、<strong>复制算法</strong>、<strong>标记-压缩算法</strong>，我们常用的垃圾回收器一般都采用<strong>分代收集算法</strong>。</p> <ul><li><strong>标记 -清除算法</strong>，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</li> <li><strong>复制算法</strong>，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</li> <li><strong>标记-压缩算法</strong>，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li> <li><strong>分代收集算法</strong>，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</li></ul> <h2 id="_17、调优命令有哪些"><a href="#_17、调优命令有哪些" class="header-anchor">#</a> 17、调优命令有哪些？</h2> <p>Sun JDK监控和故障处理命令有<strong>jps</strong> <strong>jstat</strong> <strong>jmap</strong> <strong>jhat</strong> <strong>jstack</strong> <strong>jinfo</strong></p> <ul><li><strong>jps</strong>，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li> <li><strong>jstat</strong>，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li> <li><strong>jmap</strong>，JVM Memory Map命令用于生成heap dump文件</li> <li><strong>jhat</strong>，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</li> <li><strong>jstack</strong>，用于生成java虚拟机当前时刻的线程快照。</li> <li><strong>jinfo</strong>，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li></ul></div></div>  <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=Java" title="标签">#Java</a><a href="/tags/?tag=JVM" title="标签">#JVM</a></div> <!----></div> <div class="page-nav-wapper"><!----> <!----></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:2071916845@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2023
    <span></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div id="goTop" class="hide-cat" data-v-bf92849a></div></div></div>
    <script src="/assets/js/app.b9afd737.js" defer></script><script src="/assets/js/2.a4791f69.js" defer></script><script src="/assets/js/36.01c30e39.js" defer></script>
  </body>
</html>
