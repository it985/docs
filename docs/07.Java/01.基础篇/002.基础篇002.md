---
title: 002.基础篇002
categories: 
  - Java
  - 基础
tags: 
  - Java基础
sidebar: auto
article: true
comment: true
date: 2023-01-01 12:37:58
permalink: /pages/cd3bc7/
---
# 基础篇002

## 16、Java创建对象有几种方式？

java中提供了以下四种创建对象的方式:

1.   new创建新对象
2.  通过反射机制
3.   采用clone机制
4.  通过序列化机制

## 17、有没有可能两个不相等的对象有相同的hashcode

有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以下几种方式来处理:

1.  **拉链法**:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.
2.  **开放定址法**:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入
3.  **再哈希**:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突

## 18、深拷贝和浅拷贝的区别是什么?

**浅拷贝**:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.

**深拷贝**:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍

## 19、ﬁnal有哪些用法?

final也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就不错了:

-   被final修饰的类不可以被继承
-   被final修饰的方法不可以被重写
-   被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.
-   被final修饰的方法,JVM会尝试将其内联,以提高运行效率
-   被final修饰的常量,在编译阶段会存入常量池中.

除此之外,编译器对final域要遵守的两个重排序规则更好:
在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作
之间不能重排序 初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不
能重排序.

## 20、static都有哪些用法?

所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.

除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作

```java
public calss PreCache{
    static{
    //执行相关操作
    }
}
```

此外static也多用于修饰内部类,此时称之为静态内部类.
最后一种用法就是静态导包,即`import static` .`import static`是在JDK 1.5之后引入的新特性,可以用
来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:

```java
import static java.lang.Math.*;
public class Test{
    public static void main(String[] args){
        //System.out.println(Math.sin(20));传统做法
        System.out.println(sin(20));
    }
}
```

## 21、3*0.1 == 0.3返回值是什么

false,因为有些浮点数不能完全精确的表示出来.

## 22、a=a+b与a+=b有什么区别吗?

+= 操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会自动进行类型转换.如：

```java
byte a = 127;
byte b = 127;
b = a + b; // 报编译错误:cannot convert from int to byte
b += a;
```

以下代码是否有错,有的话怎么改？

```java
short s1= 1;
s1 = s1 + 1;
```

有错误.short类型在进行运算时会自动提升为int类型,也就是说s1+1 的运算结果是int类型,而s1是
short类型,此时编译器会报错.
正确写法：

```java
short s1= 1;
s1 += 1;
```

+=操作符会对右边的表达式结果强转匹配左边的数据类型,所以没错.

## 23、try catch ﬁnally，try里有return，ﬁnally还执行么？

执行，并且finally的执行早于try里面的return

结论：
1、不管有木有出现异常，finally块中代码都会执行；
2、当try和catch中有return时，finally仍然会执行；
3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的
值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数
返回值是在finally执行前确定的；
4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。

## 24、 Excption与Error包结构

Java可抛出(Throwable)的结构分为三种类型：被检查的异常(CheckedException)，运行时异常
(RuntimeException)，错误(Error)。

#### 1、运行时异常

定义:RuntimeException及其子类都被称为运行时异常

特点:Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既"没有通过throws
声明抛出它"，也"没有用try-catch语句捕获它"，还是会编译通过。例如，除数为零时产生的
ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fast机制产
生的ConcurrentModificationException异常（java.util包下面的所有的集合类都是快速失败
的，“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上
的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线
程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的
结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出
ConcurrentModificationException 异常，从而产生fail-fast机制，这个错叫并发修改异常。Failsafe，
java.util.concurrent包下面的所有的类都是安全失败的，在遍历过程中，如果已经遍历的数
组上的内容变化了，迭代器不会抛出ConcurrentModificationException异常。如果未遍历的数组
上的内容发生了变化，则有可能反映到迭代过程中。这就是ConcurrentHashMap迭代器弱一致的
表现。ConcurrentHashMap的弱一致性主要是为了提升效率，是一致性与效率之间的一种权衡。
要成为强一致性，就得到处使用锁，甚至是全局锁，这就与Hashtable和同步的HashMap一样
了。）等，都属于运行时异常。

常见的五种运行时异常：

-    ClassCastException（类转换异常）
-    IndexOutOfBoundsException（数组越界）
-    NullPointerException（空指针异常）
-   ArrayStoreException（数据存储异常，操作数组是类型不一致）
-   BuﬀerOverﬂowException

#### 2、被检查异常

定义:Exception类本身，以及Exception的子类中除了"运行时异常"之外的其它子类都属于被检查异常。

特点 : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过 clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出 CloneNotSupportedException异常。被检查异常通常都是可以恢复的。 如：IOException，FileNotFoundException
，SQLException

#### 3、错误

定义 : Error类及其子类。

特点 : 和运行时异常一样，编译器也不会对错误进行检查。

当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。出现这种错误会导致程序终止运行。 OutOfMemoryError、ThreadDeath。

Java虚拟机规范规定JVM的内存分为了好几块，比如堆，栈，程序计数器，方法区等

## 25、OOM你遇到过哪些情况，SOF你遇到过哪些情况

### **OOM**：

#### 1，OutOfMemoryError异常

除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。

Java Heap 溢出：

一般的异常信息：`java.lang.OutOfMemoryError:Java heap spacess。`

java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。

出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(Memory Leak)还是内存溢出(Memory Overﬂow)。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GCRoots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。

如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。

#### 2，虚拟机栈和本地方法栈溢出

如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverﬂowError异常。如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常

这里需要注意当栈的大小越大可分配的线程数就越少。

#### 3，运行时常量池溢出

异常信息：`java.lang.OutOfMemoryError:PermGenspace`
如果要向运行时常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接限制其中常量池的容量。

#### 4，方法区溢出

方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。
异常信息：java.lang.OutOfMemoryError:PermGenspace方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。在经常动态生成大量Class的应用中，要特别注意这点。

### SOF（堆栈溢出StackOverﬂow）：

StackOverﬂowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。

因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。

栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、List、map数据过大。

## 26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?

**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。

**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存 中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。

## 27、Java 序列化中如果有些字段不想进行序列化，怎么办？

对于不想进行序列化的变量，使用 transient 关键字修饰。

transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。

## 28、说说Java 中 IO 流

#### Java 中 IO 流分为几种?

-   按照流的流向分，可以分为输入流和输出流；
-   按照操作单元划分，可以划分为字节流和字符流；
-   按照流的角色划分为节点流和处理流。

Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

-   InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
-   OutputStream/Writer:  所有输出流的基类，前者是字节输出流，后者是字符输出流。

按操作方式分类结构图：

![javaio1](./img/javaio1.png)

按操作对象分类结构图：
![javaio2](./img/javaio2.png)

## 29、 Java IO与 NIO的区别

NIO即New IO，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同， NIO主要用到的是块，所以NIO的效率要比IO高很多。在Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。

## 30、java反射的作用于原理

#### 1、定义：

反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。

>   这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。

#### **2、哪里会用到反射机制？**

jdbc就是典型的反射

```java
Class.forName('com.mysql.jdbc.Driver.class');//加载MySQL的驱动类
```

这就是反射。如hibernate，struts等框架使用反射实现的。

#### 3、反射的实现方式：

第一步：获取Class对象，有4中方法： 1）Class.forName(“类的路径”)； 2）类名.class 3）对象名.getClass() 4）基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象

#### 4、实现Java反射的类：

1）Class：表示正在运行的Java应用程序中的类和接口 注意： 所有获取对象的信息都需要Class类来实现。 2）Field：提供有关类和接口的属性信息，以及对它的动态访问权限。 3）Constructor：提供关于类的单个构造方法的信息以及它的访问权限 4）Method：提供类或接口中某个方法的信息

#### 5、反射机制的优缺点：

**优点：** 1）能够运行时动态获取类的实例，提高灵活性； 2）与动态编译结合 **缺点：** 1）使用反射性能较低，需要解析字节码，将内存中的对象进行解析。 解决方案： 1、通过setAccessible(true)关闭JDK的安全检查来提升反射速度； 2、多次创建一个类的实例时，有缓存会快很多 3、 ReﬂectASM工具类，通过字节码生成的方式加快反射速度 2）相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）