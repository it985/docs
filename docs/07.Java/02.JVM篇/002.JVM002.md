---
title: 002.JVM002
categories: 
  - Java
  - JVM
tags: 
  - Java
  - JVM
sidebar: auto
article: true
comment: true
---
# 002.JVM002

## 18、常见调优工具有哪些

常用调优工具分为两类,jdk自带监控工具：**jconsole**和**jvisualvm**，第三方有：**MAT**(Memory
Analyzer Tool)、**GChisto**。

-   **jconsole**，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监

    控和管理控制台，用于对JVM中内存，线程和类等的监控

-   **jvisualvm**，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。

-   **MAT**，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗

-   **GChisto**，一款专业分析gc日志的工具

## 19、Minor GC与Full GC分别在什么时候发生？

新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC

## 20、你知道哪些JVM性能调优参数？（简单版回答）

-   设定堆内存大小
-Xmx：堆内存最大限制。
-   设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代
    -   -XX:NewSize：新生代大小
    -   -XX:NewRatio 新生代和老生代占比
    -   -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比
-   设定垃圾回收器 年轻代用 -XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC

## 21、 对象一定分配在堆中吗？有没有了解逃逸分析技术？

「**对象一定分配在堆中吗？**」 不一定的，JVM通过「**逃逸分析**」，那些逃不出方法的对象会在栈上分配。

-   「什么是逃逸分析？」

    逃逸分析(Escape Analysis)，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。通俗点讲，如果一个对象的指针被多个方法或者线程引用时，那么我们就称这个对象的指针发生了逃逸。
-   「逃逸分析的好处」
  -   栈上分配，可以降低垃圾收集器运行的频率。
  -   同步消除，如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。
  -   标量替换，把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上。这样的好处有，一、减少内存使用，因为不用生成对象头。二、程序内存回收效率高，并且GC频率也会减少

## 22、虚拟机为什么使用元空间替换了永久代？

**「什么是元空间？什么是永久代？为什么用元空间代替永久代？」** 我们先回顾一下**「方法区」**吧,看看虚拟机运行时数据内存图，如下:
![jvm14.png](./img/jvm14.png)

>   方法区和堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。

#### 「**什么是永久代？它和方法区有什么关系呢？**」

>   如果在HotSpot虚拟机上开发、部署，很多程序员都把方法区称作永久代。可以说方法区是规范，永久代是Hotspot针对该规范进行的实现。在Java7及以前的版本，方法区都是永久代实现的。

#### 「**什么是元空间？它和方法区有什么关系呢？**」

>   对于Java8，HotSpots取消了永久代，取而代之的是元空间(Metaspace)。换句话说，就是方法区还是在的，只是实现变了，从永久代变为元空间了。

#### 「**为什么使用元空间替换了永久代？**」

永久代的方法区，和堆使用的物理内存是连续的。
![jvm15.png](./img/jvm15.png)

「**永久代**」是通过以下这两个参数配置大小的~

-   -XX:PremSize：设置永久代的初始大小
-   -XX:MaxPermSize: 设置永久代的最大值，默认是64M

对于「**永久代**」，如果动态生成很多class的话，就很可能出现「**java.lang.OutOfMemoryError:PermGen space错误**」，因为永久代空间配置有限嘛。最典型的场景是，在web开发比较多jsp页面的时候。JDK8之后，方法区存在于元空间(Metaspace)。物理内存不再与堆连续，而是直接存在于本地内存中，**理论**上机器「**内存有多大，元空间就有多大**」。
![jvm16.png](./img/jvm16.png)

可以通过以下的参数来设置元空间的大小：

-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。

-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集

-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集

#### 「所以，为什么使用元空间替换永久代？」

表面上看是为了避免OOM异常。因为通常使用PermSize和MaxPermSize设置永久代的大小就决定了永久代的上限，但是不是总能知道应该设置为多大合适, 如果使用默认值很容易遇到 OOM错误。当使用元空间时，可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制啦。

## 23、什么是Stop The World ? 什么是OopMap？什么是安全点？

进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为「**Stop The World**」。也简称为STW。在HotSpot中，有个数据结构（映射表）称为「**OopMap**」。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在「**特定的位置**」生成 OopMap，记录下栈上和寄存器里哪些位置是引用。
这些特定的位置主要在：

-   1.循环的末尾（非 counted 循环）
-   2.方法临返回前 / 调用方法的call指令后
-   3.可能抛异常的位置

这些位置就叫作「**安全点(safepoint)**。」 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。

## 24、说一下JVM 的主要组成部分及其作用？
![jvm17.png](./img/jvm17.png)

JVM包含两个子系统和两个组件，分别为
-   Class loader(类装载子系统)
-   Execution engine(执行引擎子系统)；
-   Runtime data area(运行时数据区组件)
-   Native Interface(本地接口组件)。
-   「**Class loader(类装载)**：」 根据给定的全限定名类名(如：java.lang.Object)来装载class文件到运行时数据区的方法区中。

-   「**Execution engine（执行引擎**）」：执行class的指令。
-   「**Native Interface(本地接口)**」： 与native lib交互，是其它编程语言交互的接口。
-   「**Runtime data area(运行时数据区域)**」：即我们常说的JVM的内存。
>首先通过编译器把 Java源代码转换成字节码，Class loader(类装载)再把字节码加载到内存中，将其放在运行时数据区的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。

## 25、什么是指针碰撞？

一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。如果Java堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是 指针碰撞。
![jvm18.png](./img/jvm18.png)

## 26，什么是空闲列表？

如果Java堆内存中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，不可以进
行指针碰撞啦，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块
大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。

### 27，什么是TLAB？

可以把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在Java堆中预先分配一小块内存,这就是TLAB（Thread Local Allocation Buffer，本地线程分配缓存） 。虚拟机通过`-XX:UseTLAB` 设定它的。

28、对象头具体都包含哪些内容？
在我们常用的Hotspot虚拟机中，对象在内存中布局实际包含3个部分：

1.  对象头
2.  实例数据
3.  对齐填充


而对象头包含两部分内容，Mark Word中的内容会随着锁标志位而发生变化，所以只说存储结就好了
- 对象自身运行时所需的数据，也被称为Mark Word，也就是用于轻量级锁和偏向锁的关键点。具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记、偏向锁线程ID、偏向锁时间戳。

- 存储类型指针，也就是指向类的元数据的指针，通过这个指针才能确定对象是属于哪个类的实例。如果是数组的话，则还包含了数组的长度。

如果是数组的话，则还包含了数组的长度。
![jvm19.png](./img/jvm19.png)

## 29、你知道哪些JVM调优参数？

#### 「堆栈内存相关」

-   -Xms 设置初始堆的大小
-   -Xmx 设置最大堆的大小
-   -Xmn 设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值
-   -Xss 每个线程的堆栈大小
-   -XX:NewSize 设置年轻代大小(for 1.3/1.4)
-   -XX:MaxNewSize 年轻代最大值(for 1.3/1.4)
-   -XX:NewRatio 年轻代与年老代的比值(除去持久代)
-   -XX:SurvivorRatio Eden区与Survivor区的的比值
-   -XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。
-   -XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代

#### 「垃圾收集器相关」

-XX:+UseParallelGC：选择垃圾收集器为并行收集器。

-   -XX:ParallelGCThreads=20：配置并行收集器的线程数
-   -XX:+UseConcMarkSweepGC：设置年老代为并发收集。
-   -XX:CMSFullGCsBeforeCompaction=5 由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。
-   -XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片

#### 「辅助信息相关」

-   -XX:+PrintGCDetails 打印GC详细信息
-   -XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,排查问题用
-   -XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题.
-   -XX:+PrintTLAB 查看TLAB空间的使用情况

## 30、说一下 JVM 有哪些垃圾回收器？

如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。不同收集器之间的连线表示它们可以搭配使用
![jvm20.png](./img/jvm20.png)

**Serial收集器（复制算法)**: 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
**ParNew收集器 (复制算法)**: 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；
**Parallel Scavenge收集器 (复制算法)**: 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
**Serial Old收集器 (标记-整理算法)**: 老年代单线程收集器，Serial收集器的老年代版本；
**Parallel Old收集器 (标记-整理算法)**： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
**CMS(Concurrent Mark Sweep)收集器（标记-清除算法）**： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。
**G1(Garbage First)收集器 (标记-整理算法)**： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。
**ZGC （Z Garbage Collector）**是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。它是基于动态Region内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的收集器。在JDK 11 新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。优点：低停顿，高吞吐量， ZGC 收集过程中额外耗费的内存小。缺点：浮动垃圾，目前使用的非常少，真正普及还是需要写时间的。

**新生代收集器**：Serial、ParNew 、Parallel Scavenge
**老年代收集器**： CMS 、Serial Old、Parallel Old
**整堆收集器**： G1 ， ZGC (因为不涉年代不在图中)。

## 31、如何选择垃圾收集器？

1. 如果你的堆大小不是很大（比如 100MB ），选择串行收集器一般是效率最高的。
参数： `-XX:+UseSerialGC` 。
2. 如果你的应用运行在单核的机器上，或者你的虚拟机核数只有单核，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益。
参数： `-XX:+UseSerialGC` 。
3. 如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的。
参数： `-XX:+UseParallelGC` 。

4. 如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择G1 、ZGC 、CMS 都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它 需要一些额外的资源去处理这些工作，通常吞吐量会低一些。
      参数：  **-XX:+UseConcMarkSweepGC** 、  **-XX:+UseG1GC** 、**-XX:+UseZGC** 等。
    从上面这些出发点来看，我们平常的 Web 服务器，都是对响应性要求非常高的。选择性其实就集中在 CMS 、G1 、ZGC 上。而对于某些定时任务，使用并行收集器，是一个比较好的选择。

## 32、 什么是类加载器？

  类加载器是一个用来加载类文件的类。Java 源代码通过 javac 编译器编译成类 文件。然后 JVM 来执 行类文件中的字节码来执行程序。类加载器负责加载文件 系统、网络或其他来源的类文件。

## 33、什么是 tomcat 类加载机制？

在 tomcat 中类的加载稍有不同，如下图：

![jvm21.png](./img/jvm21.png)

当 tomcat启动时，会创建几种类加载器： Bootstrap 引导类加载器 加载 JVM启动所需的类，以及标准扩展类（位于jre/lib/ext 下） System 系统类加载器 加载 tomcat 启动的类，比如bootstrap.jar，通常在 catalina.bat 或者 catalina.sh 中指定。位于CATALINA_HOME/bin 下。
![jvm22.png](./img/jvm22.png)