(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{365:function(_,v,a){"use strict";a.r(v);var t=a(3),r=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_002-多线程-并发篇002"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_002-多线程-并发篇002"}},[_._v("#")]),_._v(" 002.多线程&并发篇002")]),_._v(" "),v("h2",{attrs:{id:"_17、说说自己是怎么使用-synchronized-关键字"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17、说说自己是怎么使用-synchronized-关键字"}},[_._v("#")]),_._v(" 17、说说自己是怎么使用 synchronized 关键字？")]),_._v(" "),v("p",[v("strong",[_._v("修饰实例方法")]),_._v(": 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁 "),v("strong",[_._v("修饰静态方法")]),_._v(":也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，"),v("strong",[_._v("因为访问静态")]),_._v(" "),v("strong",[_._v("synchr****onized")]),_._v(" "),v("strong",[_._v("方法占用的锁是当前类的锁，而访问非静态")]),_._v(" "),v("strong",[_._v("synchr****onized")]),_._v(" "),v("strong",[_._v("方法占用的锁是当前实例对象锁。")]),_._v(" "),v("strong",[_._v("修饰代码块")]),_._v(": 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 "),v("strong",[_._v("总结")]),_._v("： synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！")]),_._v(" "),v("h2",{attrs:{id:"_18、什么是线程安全-vector是一个线程安全类吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18、什么是线程安全-vector是一个线程安全类吗"}},[_._v("#")]),_._v(" 18、什么是线程安全？Vector是一个线程安全类吗？")]),_._v(" "),v("p",[_._v("如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失")]),_._v(" "),v("p",[_._v("误。很显然你可以将集合类分 成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。")]),_._v(" "),v("h2",{attrs:{id:"_19、-volatile关键字的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19、-volatile关键字的作用"}},[_._v("#")]),_._v(" 19、 volatile关键字的作用？")]),_._v(" "),v("p",[_._v("一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：")]),_._v(" "),v("ul",[v("li",[_._v("保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。")]),_._v(" "),v("li",[_._v("禁止进行指令重排序。")]),_._v(" "),v("li",[_._v("volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。")]),_._v(" "),v("li",[_._v("volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量的修改可见性和原子性。")]),_._v(" "),v("li",[_._v("volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。")])]),_._v(" "),v("p",[_._v("volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。")]),_._v(" "),v("h2",{attrs:{id:"_20、常用的线程池有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20、常用的线程池有哪些"}},[_._v("#")]),_._v(" 20、常用的线程池有哪些？")]),_._v(" "),v("ul",[v("li",[_._v("newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。")]),_._v(" "),v("li",[_._v("newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。")]),_._v(" "),v("li",[_._v("newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。")]),_._v(" "),v("li",[_._v("newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。")]),_._v(" "),v("li",[_._v("newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。")])]),_._v(" "),v("h2",{attrs:{id:"_21、简述一下你对线程池的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21、简述一下你对线程池的理解"}},[_._v("#")]),_._v(" 21、简述一下你对线程池的理解")]),_._v(" "),v("p",[_._v("（如果问到了这样的问题，可以展开的说一下线程池如何用、线程池的好处、线程池的启动策略）合理利用线程池能够带来三个好处。")]),_._v(" "),v("ol",[v("li",[_._v("第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。")]),_._v(" "),v("li",[_._v("第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。")]),_._v(" "),v("li",[_._v("第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。")])]),_._v(" "),v("h2",{attrs:{id:"_22、java程序是如何执行的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_22、java程序是如何执行的"}},[_._v("#")]),_._v(" 22、Java程序是如何执行的")]),_._v(" "),v("p",[_._v("我们日常的工作中都使用开发工具（IntelliJ IDEA 或 Eclipse 等）可以很方便的调试程序，或者是通过打包工具把项目打包成 jar 包或者 war 包，放入 Tomcat 等 Web 容器中就可以正常运行了，但你有没有想过 Java 程序内部是如何执行的？其实不论是在开发工具中运行还是在 Tomcat 中运行， Java 程序的执行流程基本都是相同的，它的执行流程如下：")]),_._v(" "),v("ul",[v("li",[_._v("先把 Java 代码编译成字节码，也就是把 .java 类型的文件编译成 .class 类型的文件。这个过程的大致执行流程：Java 源代码 -> 词法分析器 -> 语法分析器 -> 语义分析器 -> 字符码生成器 ->最终生成字节码，其中任何一个节点执行失败就会造成编译失败；")]),_._v(" "),v("li",[_._v("把 class 文件放置到 Java 虚拟机，这个虚拟机通常指的是 Oracle 官方自带的 Hotspot JVM；")]),_._v(" "),v("li",[_._v("Java 虚拟机使用类加载器（Class Loader）装载 class 文件；")]),_._v(" "),v("li",[_._v("类加载完成之后，会进行字节码效验，字节码效验通过之后 JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以 Hotspot 虚拟机来说，它本身提供了 JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。Java 程序执行流程图如下：\n"),v("img",{attrs:{src:"https://npm.elemecdn.com/@it985/docsimages/001/MultithreadingConcurrency1.png",alt:"MultithreadingConcurrency1"}})])]),_._v(" "),v("h2",{attrs:{id:"_23、锁的优化机制了解吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_23、锁的优化机制了解吗"}},[_._v("#")]),_._v(" 23、锁的优化机制了解吗？")]),_._v(" "),v("p",[_._v("从JDK1.6版本之后，synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。")]),_._v(" "),v("p",[_._v("锁的状态从低到高依次为**无锁****->"),v("strong",[v("strong",[_._v("偏向锁")])]),_._v("->"),v("strong",[v("strong",[_._v("轻量级锁")])]),_._v("->**"),v("strong",[_._v("重量级锁")]),_._v("，升级的过程就是从低到高，降级在一定条件也是有可能发生的。")]),_._v(" "),v("p",[v("strong",[_._v("自旋锁")]),_._v("：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环，可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10次，可以使用-XX:PreBlockSpin设置。")]),_._v(" "),v("p",[v("strong",[_._v("自适应锁")]),_._v("：自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。")]),_._v(" "),v("p",[v("strong",[_._v("锁消除")]),_._v("：锁消除指的是JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。")]),_._v(" "),v("p",[v("strong",[_._v("锁粗化")]),_._v("：锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围扩展到整个操作序列之外。")]),_._v(" "),v("p",[v("strong",[_._v("偏向锁")]),_._v("：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线 程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以用过设置-XX:+UseBiasedLocking开启偏向锁。")]),_._v(" "),v("p",[v("strong",[_._v("轻量级锁")]),_._v("：JVM的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM将会使用 CAS方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败，当前线程就尝试自旋来获得锁。")]),_._v(" "),v("p",[_._v("整个锁升级的过程非常复杂，我尽力去除一些无用的环节，简单来描述整个升级的机制。")]),_._v(" "),v("p",[_._v("简单点说，偏向锁就是通过对象头的偏向线程ID来对比，甚至都不需要CAS了，而轻量级锁主要就是通过CAS修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。\n"),v("img",{attrs:{src:"https://npm.elemecdn.com/@it985/docsimages/001/MultithreadingConcurrency2.png",alt:"MultithreadingConcurrency2"}})]),_._v(" "),v("h2",{attrs:{id:"_24、说说进程和线程的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_24、说说进程和线程的区别"}},[_._v("#")]),_._v(" 24、说说进程和线程的区别？")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("进程是一个“执行中的程序”，是系统进行资源分配和调度的一个独立单位。")])]),_._v(" "),v("li",[v("p",[_._v("线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）")])]),_._v(" "),v("li",[v("p",[_._v("线程上下文的切换比进程上下文切换要快很多。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。")])]),_._v(" "),v("li",[v("p",[_._v("线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。")])])])])]),_._v(" "),v("h2",{attrs:{id:"_25-产生死锁的四个必要条件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_25-产生死锁的四个必要条件"}},[_._v("#")]),_._v(" 25，产生死锁的四个必要条件？")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("互斥条件：一个资源每次只能被一个线程使用")])]),_._v(" "),v("li",[v("p",[_._v("请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放")])]),_._v(" "),v("li",[v("p",[_._v("不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺")])]),_._v(" "),v("li",[v("p",[_._v("循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系")])])]),_._v(" "),v("h2",{attrs:{id:"_26、如何避免死锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_26、如何避免死锁"}},[_._v("#")]),_._v(" 26、如何避免死锁？")]),_._v(" "),v("p",[_._v("指定获取锁的顺序，举例如下：")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("比如某个线程只有获得A锁和B锁才能对某资源进行操作，在多线程条件下，如何避免死锁？")])]),_._v(" "),v("li",[v("p",[_._v("获得锁的顺序是一定的，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁！！！")])])]),_._v(" "),v("h2",{attrs:{id:"_27-线程池核心线程数怎么设置呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_27-线程池核心线程数怎么设置呢"}},[_._v("#")]),_._v(" 27，线程池核心线程数怎么设置呢？")]),_._v(" "),v("p",[_._v("分为CPU密集型和IO密集型")]),_._v(" "),v("h4",{attrs:{id:"cpu"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cpu"}},[_._v("#")]),_._v(" CPU")]),_._v(" "),v("p",[_._v("这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。")]),_._v(" "),v("h4",{attrs:{id:"io密集型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#io密集型"}},[_._v("#")]),_._v(" IO密集型")]),_._v(" "),v("p",[_._v("这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 ： 核心线程数=CPU核心数量*2。")]),_._v(" "),v("h2",{attrs:{id:"_28-java线程池中队列常用类型有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_28-java线程池中队列常用类型有哪些"}},[_._v("#")]),_._v(" 28，Java线程池中队列常用类型有哪些？")]),_._v(" "),v("ol",[v("li",[v("p",[v("strong",[v("code",[_._v("ArrayBlockingQueue")])]),_._v(" 是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。")])]),_._v(" "),v("li",[v("p",[v("strong",[v("code",[_._v("LinkedBlockingQueue")])]),_._v(" 一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue 。")])]),_._v(" "),v("li",[v("p",[v("strong",[v("code",[_._v("SynchronousQueue")])]),_._v(" 一个不存储元素的阻塞队列。")])]),_._v(" "),v("li",[v("p",[v("strong",[v("code",[_._v("PriorityBlockingQueue")])]),_._v(" 一个具有优先级的无限阻塞队列。PriorityBlockingQueue 也是基于最小二叉堆实现")])]),_._v(" "),v("li",[v("p",[v("strong",[v("code",[_._v("DelayQueue")])])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("只有当其指定的延迟时间到了，才能够从队列中获取到该元素。")])]),_._v(" "),v("li",[v("p",[_._v("DelayQueue 是一个没有大小限制的队列，")])]),_._v(" "),v("li",[v("p",[_._v("因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费")])]),_._v(" "),v("li",[v("p",[_._v("者）才会被阻塞。")])])])])]),_._v(" "),v("h2",{attrs:{id:"_29-线程安全需要保证几个基本特征"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_29-线程安全需要保证几个基本特征"}},[_._v("#")]),_._v(" 29，线程安全需要保证几个基本特征？")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("原子性")]),_._v("，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。")]),_._v(" "),v("li",[v("strong",[_._v("可见性")]),_._v("，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。")]),_._v(" "),v("li",[v("strong",[_._v("有序性")]),_._v("，是保证线程内串行语义，避免指令重排等。")])]),_._v(" "),v("h2",{attrs:{id:"_30-说一下线程之间是如何通信的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_30-说一下线程之间是如何通信的"}},[_._v("#")]),_._v(" 30，说一下线程之间是如何通信的？")]),_._v(" "),v("p",[_._v("线程之间的通信有两种方式：共享内存和消息传递。")]),_._v(" "),v("h4",{attrs:{id:"共享内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#共享内存"}},[_._v("#")]),_._v(" 共享内存")]),_._v(" "),v("p",[_._v("在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来\n隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。\n例如线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：")]),_._v(" "),v("ol",[v("li",[_._v("线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去。")]),_._v(" "),v("li",[_._v("线程 B 到主内存中去读取线程 A 之前更新过的共享变量。")])]),_._v(" "),v("h4",{attrs:{id:"消息传递"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息传递"}},[_._v("#")]),_._v(" 消息传递")]),_._v(" "),v("p",[_._v("在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行\n通信。在 Java 中典型的消息传递方式，就是 "),v("code",[_._v("wait()")]),_._v(" 和 "),v("code",[_._v("notify()")]),_._v(" ，或者"),v("code",[_._v("BlockingQueue")]),_._v(" 。")])])}),[],!1,null,null,null);v.default=r.exports}}]);